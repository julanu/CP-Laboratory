1.  
  347 (base 10) = 533 (base 8)
  2755 (base 10) = AC3 (base 16)
  20 (base 10) = 10100(base 2)

2.
  1000101 (base 2) = 69 (base 10)
  357 (base 8) = 239 (base 10)
  C7A (base 16) = 3194 (base 10)

3.
a)  FA + 23 = 11D (addition in base 16)

b)  1101 0010 + 1110 1101 = 1101 1111 (addition in base 2)

c)  1176 - 723 = 253 (substraction in base 8)

4.
a) 10101010, 110010 (base 2) = 252, 62 (base 8) determined by using the bit grouping method; 3 for base 8
  
   10101010, 110010 (base 2) = AA, C8 (base 16) determined by using the bit grouping method; 4 for base 16

b) 1100010, 11101 (base 2) = 142, 72 (base 8)

   1100010, 11101 (base 2) = 62, E8 (base 16)

5. 175.1285 (base 10) = 2233.0200321 (base 4)


6. 	Bubble Sort

//considering v[] an array of the elements to be sorted
//n - size of the array

function bubble_sort(v[], n)
{
  for index = 0 to n - 1
    for index2 = 0 to n - 1
      {
	if (v[index] > v[index2])
	  {
	  aux = v[index];
	  v[index] = v[index2];
	  v[index2] = aux;
	  } //end if

	} //end of for loop

} //end of function

	Quick Sort

// the sorting function
// low,high - starting and ending index
// A[] to be considered the array that must be sorted

function quicksort(A[], low, high)
{
    if(low > high)
        return ;

    if (low < high)
      {
        pivot = partition(A, low, high);
        quicksort(A, low, pivot â€“ 1);
        quicksort(A, pivot + 1, hi);
      }

}

//the algorithm for partitioning the array

function partition(A[], low, high)
{

    pivot = A[high];
    index = low - 1;  // index of smaller element 

    for index2 = low to high - 1 
      {
        if (A[index2] < pivot)
	  {
            i = i + 1;

	    aux = A[index];
	    A[index] = A[index2]; //we swap A[index] with A[index2]
	    A[index2] = aux;
	   } //end if
      } //end for

    return (i + 1);

} //end function


	Counting Sort

//note that this algorithm uses a lot of memory
// count - counting array
// output - array to temporary store the sorted array

function countSort(A[], n)
{
	

    //we store the count of each integer
    for ind = 0 to n -1
        ++count[A[ind]];
 
    // we now change count[i] so that the new count[i] contains the actual
    // position of the int in the array

    for ind = 0 to n - 1
        count[ind] += count[ind - 1];
 
    // we now compute the output array in such a way that the
    // array will come up sorted
    for ind = 0 to n - 1
    {
        output[count[arr[ind]] - 1] = arr[ind];
        --count[arr[ind]];
    }
 
    // we copy the output array to the initial array A[]
    // so that it contains the sorted elements
    for ind = 1 to n - 1
        arr[ind] = output[ind];
}


7.
int greatestCommonDivisor(int a, int b)
{
    if(a == 0 || b == 0)
	return ;
    
    if(a == 1 || b == 1)
	return 1;
    
    while(a != b)
	if(a > b)
	  a = a - b;
	else
	  b = b - a;

  return a;
}


8.

